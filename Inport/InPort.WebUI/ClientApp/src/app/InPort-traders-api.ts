/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICustomersClient {
    getAll(): Observable<CustomersListViewModel | null>;
    get(id: string | null): Observable<CustomerDetailModel | null>;
    create(command: CreateCustomerCommand): Observable<void>;
    update(id: string | null, command: UpdateCustomerCommand): Observable<void>;
    delete(id: string): Observable<void>;
}

@Injectable()
export class CustomersClient implements ICustomersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAll(): Observable<CustomersListViewModel | null> {
        let url_ = this.baseUrl + "/api/Customers/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CustomersListViewModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomersListViewModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CustomersListViewModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomersListViewModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomersListViewModel | null>(<any>null);
    }

    get(id: string | null): Observable<CustomerDetailModel | null> {
        let url_ = this.baseUrl + "/api/Customers/Get/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDetailModel | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDetailModel | null>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CustomerDetailModel | null> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerDetailModel.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDetailModel | null>(<any>null);
    }

    create(command: CreateCustomerCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Customers/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        }
    }

    update(id: string | null, command: UpdateCustomerCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/Customers/Update/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        }
    }

    delete(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Customers/Delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        }
    }
}

export class CustomersListViewModel implements ICustomersListViewModel {
    customers?: CustomerLookupModel[] | undefined;

    constructor(data?: ICustomersListViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["customers"] && data["customers"].constructor === Array) {
                this.customers = [] as any;
                for (let item of data["customers"])
                    this.customers!.push(CustomerLookupModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomersListViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomersListViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.customers && this.customers.constructor === Array) {
            data["customers"] = [];
            for (let item of this.customers)
                data["customers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomersListViewModel {
    customers?: CustomerLookupModel[] | undefined;
}

export class CustomerLookupModel implements ICustomerLookupModel {
    id?: string | undefined;
    name?: string | undefined;

    constructor(data?: ICustomerLookupModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CustomerLookupModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerLookupModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICustomerLookupModel {
    id?: string | undefined;
    name?: string | undefined;
}

export class CustomerDetailModel implements ICustomerDetailModel {
    id?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    companyName?: string | undefined;
    contactName?: string | undefined;
    contactTitle?: string | undefined;
    country?: string | undefined;
    fax?: string | undefined;
    phone?: string | undefined;
    postalCode?: string | undefined;
    region?: string | undefined;

    constructor(data?: ICustomerDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.address = data["address"];
            this.city = data["city"];
            this.companyName = data["companyName"];
            this.contactName = data["contactName"];
            this.contactTitle = data["contactTitle"];
            this.country = data["country"];
            this.fax = data["fax"];
            this.phone = data["phone"];
            this.postalCode = data["postalCode"];
            this.region = data["region"];
        }
    }

    static fromJS(data: any): CustomerDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["address"] = this.address;
        data["city"] = this.city;
        data["companyName"] = this.companyName;
        data["contactName"] = this.contactName;
        data["contactTitle"] = this.contactTitle;
        data["country"] = this.country;
        data["fax"] = this.fax;
        data["phone"] = this.phone;
        data["postalCode"] = this.postalCode;
        data["region"] = this.region;
        return data; 
    }
}

export interface ICustomerDetailModel {
    id?: string | undefined;
    address?: string | undefined;
    city?: string | undefined;
    companyName?: string | undefined;
    contactName?: string | undefined;
    contactTitle?: string | undefined;
    country?: string | undefined;
    fax?: string | undefined;
    phone?: string | undefined;
    postalCode?: string | undefined;
    region?: string | undefined;
}

export abstract class Message implements IMessage {
    messageType?: string | undefined;
    aggregateId?: string;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.messageType = data["messageType"];
            this.aggregateId = data["aggregateId"];
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Message' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["messageType"] = this.messageType;
        data["aggregateId"] = this.aggregateId;
        return data; 
    }
}

export interface IMessage {
    messageType?: string | undefined;
    aggregateId?: string;
}

export abstract class Command extends Message implements ICommand {
    timestamp?: Date;
    validationResult?: ValidationResult | undefined;

    constructor(data?: ICommand) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.timestamp = data["timestamp"] ? new Date(data["timestamp"].toString()) : <any>undefined;
            this.validationResult = data["validationResult"] ? ValidationResult.fromJS(data["validationResult"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Command {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'Command' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timestamp"] = this.timestamp ? this.timestamp.toISOString() : <any>undefined;
        data["validationResult"] = this.validationResult ? this.validationResult.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ICommand extends IMessage {
    timestamp?: Date;
    validationResult?: ValidationResult | undefined;
}

export abstract class CustomerCommand extends Command implements ICustomerCommand {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    telephone?: string | undefined;
    company?: string | undefined;
    email?: string | undefined;
    addressCity?: string | undefined;
    addressZipCode?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    countryId?: string;

    constructor(data?: ICustomerCommand) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.id = data["id"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.telephone = data["telephone"];
            this.company = data["company"];
            this.email = data["email"];
            this.addressCity = data["addressCity"];
            this.addressZipCode = data["addressZipCode"];
            this.addressLine1 = data["addressLine1"];
            this.addressLine2 = data["addressLine2"];
            this.countryId = data["countryId"];
        }
    }

    static fromJS(data: any): CustomerCommand {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CustomerCommand' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["telephone"] = this.telephone;
        data["company"] = this.company;
        data["email"] = this.email;
        data["addressCity"] = this.addressCity;
        data["addressZipCode"] = this.addressZipCode;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["countryId"] = this.countryId;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerCommand extends ICommand {
    id?: string;
    firstName?: string | undefined;
    lastName?: string | undefined;
    telephone?: string | undefined;
    company?: string | undefined;
    email?: string | undefined;
    addressCity?: string | undefined;
    addressZipCode?: string | undefined;
    addressLine1?: string | undefined;
    addressLine2?: string | undefined;
    countryId?: string;
}

export class CreateCustomerCommand extends CustomerCommand implements ICreateCustomerCommand {

    constructor(data?: ICreateCustomerCommand) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): CreateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICreateCustomerCommand extends ICustomerCommand {
}

/** The result of running a validator */
export class ValidationResult implements IValidationResult {
    /** Whether validation succeeded */
    isValid?: boolean;
    /** A collection of errors */
    errors?: ValidationFailure[] | undefined;
    ruleSetsExecuted?: string[] | undefined;

    constructor(data?: IValidationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isValid = data["isValid"];
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [] as any;
                for (let item of data["errors"])
                    this.errors!.push(ValidationFailure.fromJS(item));
            }
            if (data["ruleSetsExecuted"] && data["ruleSetsExecuted"].constructor === Array) {
                this.ruleSetsExecuted = [] as any;
                for (let item of data["ruleSetsExecuted"])
                    this.ruleSetsExecuted!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isValid"] = this.isValid;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        if (this.ruleSetsExecuted && this.ruleSetsExecuted.constructor === Array) {
            data["ruleSetsExecuted"] = [];
            for (let item of this.ruleSetsExecuted)
                data["ruleSetsExecuted"].push(item);
        }
        return data; 
    }
}

/** The result of running a validator */
export interface IValidationResult {
    /** Whether validation succeeded */
    isValid?: boolean;
    /** A collection of errors */
    errors?: ValidationFailure[] | undefined;
    ruleSetsExecuted?: string[] | undefined;
}

/** Defines a validation failure */
export class ValidationFailure implements IValidationFailure {
    /** The name of the property. */
    propertyName?: string | undefined;
    /** The error message */
    errorMessage?: string | undefined;
    /** The property value that caused the failure. */
    attemptedValue?: any | undefined;
    /** Custom state associated with the failure. */
    customState?: any | undefined;
    /** Custom severity level associated with the failure. */
    severity?: Severity;
    /** Gets or sets the error code. */
    errorCode?: string | undefined;
    /** Gets or sets the formatted message arguments.
These are values for custom formatted message in validator resource files
Same formatted message can be reused in UI and with same number of format placeholders
Like "Value {0} that you entered should be {1}" */
    formattedMessageArguments?: any[] | undefined;
    /** Gets or sets the formatted message placeholder values. */
    formattedMessagePlaceholderValues?: { [key: string] : any; } | undefined;
    /** The resource name used for building the message */
    resourceName?: string | undefined;

    constructor(data?: IValidationFailure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.propertyName = data["propertyName"];
            this.errorMessage = data["errorMessage"];
            this.attemptedValue = data["attemptedValue"];
            this.customState = data["customState"];
            this.severity = data["severity"];
            this.errorCode = data["errorCode"];
            if (data["formattedMessageArguments"] && data["formattedMessageArguments"].constructor === Array) {
                this.formattedMessageArguments = [] as any;
                for (let item of data["formattedMessageArguments"])
                    this.formattedMessageArguments!.push(item);
            }
            if (data["formattedMessagePlaceholderValues"]) {
                this.formattedMessagePlaceholderValues = {} as any;
                for (let key in data["formattedMessagePlaceholderValues"]) {
                    if (data["formattedMessagePlaceholderValues"].hasOwnProperty(key))
                        this.formattedMessagePlaceholderValues![key] = data["formattedMessagePlaceholderValues"][key];
                }
            }
            this.resourceName = data["resourceName"];
        }
    }

    static fromJS(data: any): ValidationFailure {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationFailure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["errorMessage"] = this.errorMessage;
        data["attemptedValue"] = this.attemptedValue;
        data["customState"] = this.customState;
        data["severity"] = this.severity;
        data["errorCode"] = this.errorCode;
        if (this.formattedMessageArguments && this.formattedMessageArguments.constructor === Array) {
            data["formattedMessageArguments"] = [];
            for (let item of this.formattedMessageArguments)
                data["formattedMessageArguments"].push(item);
        }
        if (this.formattedMessagePlaceholderValues) {
            data["formattedMessagePlaceholderValues"] = {};
            for (let key in this.formattedMessagePlaceholderValues) {
                if (this.formattedMessagePlaceholderValues.hasOwnProperty(key))
                    data["formattedMessagePlaceholderValues"][key] = this.formattedMessagePlaceholderValues[key];
            }
        }
        data["resourceName"] = this.resourceName;
        return data; 
    }
}

/** Defines a validation failure */
export interface IValidationFailure {
    /** The name of the property. */
    propertyName?: string | undefined;
    /** The error message */
    errorMessage?: string | undefined;
    /** The property value that caused the failure. */
    attemptedValue?: any | undefined;
    /** Custom state associated with the failure. */
    customState?: any | undefined;
    /** Custom severity level associated with the failure. */
    severity?: Severity;
    /** Gets or sets the error code. */
    errorCode?: string | undefined;
    /** Gets or sets the formatted message arguments.
These are values for custom formatted message in validator resource files
Same formatted message can be reused in UI and with same number of format placeholders
Like "Value {0} that you entered should be {1}" */
    formattedMessageArguments?: any[] | undefined;
    /** Gets or sets the formatted message placeholder values. */
    formattedMessagePlaceholderValues?: { [key: string] : any; } | undefined;
    /** The resource name used for building the message */
    resourceName?: string | undefined;
}

/** Specifies the severity of a rule. */
export enum Severity {
    Error = 0, 
    Warning = 1, 
    Info = 2, 
}

export class UpdateCustomerCommand extends CustomerCommand implements IUpdateCustomerCommand {

    constructor(data?: IUpdateCustomerCommand) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): UpdateCustomerCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCustomerCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IUpdateCustomerCommand extends ICustomerCommand {
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}